cd---
title: "Why Converting WordPress to Static HTML Is Harder Than It Looks"
description: "The deceptively difficult journey of migrating a WordPress site to static HTML, and why I ended up just running WordPress properly instead."
pubDate: 2026-02-03
tags: ["building-in-public", "engineering", "wordpress", "web-development"]
draft: false
generatedBy: "agent"

---

## Context

WordPress powers something like 40% of the web. It's the Swiss Army knife of content management systems—powerful, flexible, battle-tested. But it's also heavy. It requires PHP, MySQL, server-side rendering, and carries decades of architectural decisions.

So when I wanted to migrate a WordPress site to something lighter and faster, static HTML seemed like the obvious answer. Just extract the content, grab the styles, and host it anywhere. How hard could it be?

Turns out: pretty hard.

## Original Plan

The plan was simple and logical:

1. Use an LLM to help convert the WordPress site to static HTML/CSS
2. Extract all the content from the WordPress database
3. Recreate the pages as static files
4. Deploy to a static host like Surge
5. Enjoy the speed, simplicity, and low cost of static hosting

The promise was compelling: no database, no PHP, no server overhead. Just files served fast from a CDN. Modern static site generators like Astro, Hugo, and Eleventy make this look easy. Surely an LLM could help bridge the gap from WordPress to static files.

## What Changed

Reality hit quickly. While LLMs are excellent at many coding tasks—refactoring, explaining code, writing boilerplate—they struggle with WordPress-to-static conversion. Not because they're bad at code, but because this specific problem has hidden complexity that doesn't fit the pattern-matching approach LLMs excel at.

### The WordPress Complexity Problem

WordPress isn't just a collection of HTML files. It's a dynamic application with layers of abstraction:

- **Dynamic content generation**: Pages are assembled on-the-fly from database queries, template files, and PHP logic
- **Database-driven everything**: Posts, pages, settings, user data—all stored in MySQL with complex relationships
- **Theme dependencies**: Your content is tightly coupled to theme files that use WordPress-specific functions and template tags
- **Plugin functionality**: Features you take for granted might be generated by plugins—contact forms, galleries, custom post types
- **URL structures and routing**: Pretty permalinks, pagination, category archives—all handled by WordPress's rewrite engine

When you view a WordPress page in your browser, you're seeing the output of a complex rendering pipeline. Extracting that to static HTML means capturing not just the final HTML, but understanding all the dynamic pieces that generated it.

## Iterations and Fixes

### Attempt 1: The "Works on My Machine" Problem

The initial conversion attempts actually produced something that looked promising. The static site opened in a browser locally and appeared to work. The HTML was there, the CSS loaded, images showed up. Success, right?

Not quite.

When I deployed to Surge, things fell apart. Broken links. Missing assets. Pages that worked locally returned 404s. This was a classic "works on my machine" scenario, but worse—because the local success was misleading. The site wasn't truly static; it still relied on local file paths and structures that didn't translate to a hosted environment.

The issues stemmed from:

- Absolute vs. relative paths
- WordPress's complex URL rewriting not translating to static files
- Assets referenced in ways that assumed WordPress's directory structure
- Database-driven menus and navigation that needed to be hardcoded

Each fix revealed another layer of problems. It became clear this wasn't a straightforward conversion—it was reverse-engineering a dynamic application.

### Attempt 2: Just Run WordPress Properly

Eventually, I admitted defeat on the "simple" solution and went back to basics: run WordPress as it was designed to be run.

The new approach:

1. Use the **All-in-One WP Migration** plugin to create a complete backup of the WordPress site
2. Spin up a DigitalOcean droplet with PHP and MySQL
3. Install WordPress on the droplet
4. Restore the backup

This should have been straightforward, but of course there was friction. WordPress and the migration plugin have default PHP upload limits that are smaller than most real-world site backups. I had to SSH into the server and modify `php.ini`:

```ini
upload_max_filesize = 512M
post_max_size = 512M
```

After restarting PHP-FPM, the migration completed successfully. The site worked exactly as it had before—because it was still WordPress, just on new infrastructure.

## What I Learned

### 1. Sometimes the "Simple" Solution Isn't Actually Simpler

Static sites are simpler in production, but getting there from WordPress is not simple. The migration complexity can outweigh the operational simplicity you're aiming for.

If you're starting fresh, a static site generator is great. But retrofitting an existing WordPress site is a different beast.

### 2. WordPress Complexity Is Invisible Until You Try to Work Around It

When WordPress is working, you don't think about all the layers: the template hierarchy, the loop, the query system, the hooks and filters. It just works.

Trying to extract content reveals how much invisible machinery is running. Every page is the output of potentially dozens of PHP files, database queries, and template includes.

### 3. Running WordPress Properly Might Be Easier Than Escaping It

Modern managed WordPress hosting (or a well-configured VPS) isn't that complicated or expensive. For sites that are already WordPress, keeping them as WordPress—but on good infrastructure—is often the path of least resistance.

Fighting WordPress's architecture is exhausting. Embracing it and optimizing it is often smarter.

### 4. LLMs Have Limits on Complex CMS Migrations

LLMs are incredibly useful for:

- Writing boilerplate code
- Explaining unfamiliar syntax
- Refactoring within a known framework
- Generating test cases

But they struggle with:

- Understanding the full context of a complex CMS
- Navigating the edge cases of a real-world site (custom plugins, theme modifications, content quirks)
- Debugging environment-specific issues (local vs. production behavior)
- Making architectural decisions about tradeoffs

The WordPress-to-static problem has too many variables and too many ways to fail. An LLM can help with individual steps, but it can't reason about the entire problem space reliably.

## Next Steps

The site is now running on a DigitalOcean droplet with WordPress properly configured. It's fast enough, maintainable, and most importantly—it works.

If I were to attempt a static migration in the future, I'd approach it differently:

- Use a WordPress plugin specifically designed for static site generation (like Simply Static or WP2Static)
- Plan for manual cleanup and testing of every page type
- Accept that some dynamic features will need to be replaced or removed
- Budget significantly more time than it "should" take

Or, more likely: I'd just run WordPress on solid infrastructure and call it a day.

## Closing Thoughts

This experience was humbling. What seemed like a straightforward conversion—just HTML and CSS, right?—turned into a lesson in hidden complexity and the limitations of both AI tools and my own assumptions.

Sometimes the boring solution is the right solution. WordPress has its quirks, but it's also solved countless problems over decades of development. Fighting that momentum is often more work than it's worth.

And that's okay. Not every problem needs a clever solution. Sometimes you just need PHP and MySQL running reliably on a server.
